<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Long Running Job WebSocket Test</title>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        background: white;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      h1 {
        color: #333;
        border-bottom: 3px solid #4caf50;
        padding-bottom: 10px;
      }
      h2 {
        color: #555;
        margin-top: 0;
      }
      .status {
        padding: 10px;
        border-radius: 4px;
        margin: 10px 0;
        font-weight: bold;
      }
      .status.connected {
        background-color: #d4edda;
        color: #155724;
      }
      .status.disconnected {
        background-color: #f8d7da;
        color: #721c24;
      }
      .status.connecting {
        background-color: #fff3cd;
        color: #856404;
      }
      button {
        background-color: #4caf50;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
        font-size: 14px;
      }
      button:hover {
        background-color: #45a049;
      }
      button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
      .danger {
        background-color: #f44336;
      }
      .danger:hover {
        background-color: #da190b;
      }
      input {
        padding: 8px;
        margin: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 300px;
      }
      .log {
        background-color: #1e1e1e;
        color: #d4d4d4;
        padding: 15px;
        border-radius: 4px;
        height: 400px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 12px;
      }
      .log-entry {
        margin: 2px 0;
        padding: 2px 0;
      }
      .log-entry.info {
        color: #4ec9b0;
      }
      .log-entry.success {
        color: #6a9955;
      }
      .log-entry.warning {
        color: #ce9178;
      }
      .log-entry.error {
        color: #f48771;
      }
      .progress-bar {
        width: 100%;
        height: 30px;
        background-color: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        margin: 10px 0;
      }
      .progress-fill {
        height: 100%;
        background-color: #4caf50;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin: 10px 0;
      }
      .stat-card {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 4px;
        border-left: 4px solid #4caf50;
      }
      .stat-label {
        color: #666;
        font-size: 12px;
        text-transform: uppercase;
      }
      .stat-value {
        color: #333;
        font-size: 24px;
        font-weight: bold;
        margin-top: 5px;
      }
    </style>
  </head>
  <body>
    <h1>üöÄ Long Running Job WebSocket Test</h1>

    <div class="container">
      <h2>Connection Settings</h2>
      <div>
        <input
          type="text"
          id="serverUrl"
          placeholder="Server URL"
          value="http://localhost:3000"
        />
        <input
          type="text"
          id="roomId"
          placeholder="Room/User ID"
          value="user123"
        />
      </div>
      <div>
        <button onclick="connect()">Connect</button>
        <button onclick="disconnect()" class="danger">Disconnect</button>
        <button onclick="clearLogs()">Clear Logs</button>
      </div>
      <div id="connectionStatus" class="status disconnected">
        ‚ùå Disconnected
      </div>
    </div>

    <div class="container">
      <h2>Connection Statistics</h2>
      <div class="stats">
        <div class="stat-card">
          <div class="stat-label">Uptime</div>
          <div class="stat-value" id="uptime">0s</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Pings Sent</div>
          <div class="stat-value" id="pingCount">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Messages Received</div>
          <div class="stat-value" id="messageCount">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Reconnect Count</div>
          <div class="stat-value" id="reconnectCount">0</div>
        </div>
      </div>
    </div>

    <div class="container">
      <h2>Job Progress</h2>
      <div class="progress-bar">
        <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
      </div>
      <div id="progressMessage" style="color: #666; margin-top: 10px">
        Waiting for job to start...
      </div>
    </div>

    <div class="container">
      <h2>Actions</h2>
      <button onclick="joinRoom()">Join Room</button>
      <button onclick="leaveRoom()">Leave Room</button>
      <button onclick="sendPing()">Send Manual Ping</button>
      <button onclick="simulateLongJob()">Simulate Long Job (15+ min)</button>
    </div>

    <div class="container">
      <h2>Event Log</h2>
      <div class="log" id="eventLog"></div>
    </div>

    <script>
      let socket = null;
      let pingInterval = null;
      let uptimeInterval = null;
      let stats = {
        connectedAt: null,
        pingCount: 0,
        messageCount: 0,
        reconnectCount: 0,
      };

      function log(message, type = 'info') {
        const logDiv = document.getElementById('eventLog');
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${timestamp}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(message);
      }

      function updateStatus(status, message) {
        const statusDiv = document.getElementById('connectionStatus');
        statusDiv.className = `status ${status}`;
        statusDiv.textContent = message;
      }

      function updateStats() {
        document.getElementById('pingCount').textContent = stats.pingCount;
        document.getElementById('messageCount').textContent =
          stats.messageCount;
        document.getElementById('reconnectCount').textContent =
          stats.reconnectCount;
      }

      function updateUptime() {
        if (stats.connectedAt) {
          const uptime = Math.floor((Date.now() - stats.connectedAt) / 1000);
          const minutes = Math.floor(uptime / 60);
          const seconds = uptime % 60;
          document.getElementById('uptime').textContent =
            minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
        }
      }

      function updateProgress(progress, message) {
        const progressBar = document.getElementById('progressBar');
        const progressMsg = document.getElementById('progressMessage');
        progressBar.style.width = `${progress}%`;
        progressBar.textContent = `${progress}%`;
        progressMsg.textContent = message || `Processing... ${progress}%`;
      }

      function connect() {
        const serverUrl = document.getElementById('serverUrl').value;

        if (socket && socket.connected) {
          log('Already connected!', 'warning');
          return;
        }

        log(`Connecting to ${serverUrl}...`, 'info');
        updateStatus('connecting', 'üîÑ Connecting...');

        socket = io(serverUrl, {
          transports: ['websocket', 'polling'],
          upgrade: true,
          timeout: 60000,
          // Critical settings for long-running jobs
          reconnection: true,
          reconnectionAttempts: Infinity,
          reconnectionDelay: 2000,
          reconnectionDelayMax: 10000,
          randomizationFactor: 0.5,
          // Keep-alive settings matching server (UPDATED for heavy video processing)
          pingTimeout: 120000, // Match server: 120 seconds (2 minutes)
          pingInterval: 45000, // Match server: 45 seconds
        });

        setupSocketEvents();
      }

      function setupSocketEvents() {
        // Connection events
        socket.on('connect', () => {
          log('‚úÖ Connected! Socket ID: ' + socket.id, 'success');
          updateStatus('connected', '‚úÖ Connected - Socket ID: ' + socket.id);
          stats.connectedAt = Date.now();

          // Start keep-alive ping
          startKeepAlivePing();

          // Start uptime counter
          if (uptimeInterval) clearInterval(uptimeInterval);
          uptimeInterval = setInterval(updateUptime, 1000);

          // Auto-join room
          setTimeout(() => joinRoom(), 500);
        });

        socket.on('disconnect', (reason) => {
          log(`‚ùå Disconnected: ${reason}`, 'error');
          updateStatus('disconnected', `‚ùå Disconnected - Reason: ${reason}`);
          stats.connectedAt = null;

          if (pingInterval) {
            clearInterval(pingInterval);
            pingInterval = null;
          }

          if (uptimeInterval) {
            clearInterval(uptimeInterval);
            uptimeInterval = null;
          }
        });

        socket.on('reconnect_attempt', (attemptNumber) => {
          log(`üîÑ Reconnection attempt ${attemptNumber}...`, 'warning');
          updateStatus(
            'connecting',
            `üîÑ Reconnecting... Attempt ${attemptNumber}`
          );
        });

        socket.on('reconnect', (attemptNumber) => {
          stats.reconnectCount++;
          updateStats();
          log(`‚úÖ Reconnected after ${attemptNumber} attempts`, 'success');
        });

        socket.on('error', (error) => {
          log(`üö® Socket error: ${JSON.stringify(error)}`, 'error');
        });

        // Server responses
        socket.on('pong', (data) => {
          stats.messageCount++;
          updateStats();
          log('üì° Received pong from server', 'info');
        });

        socket.on('room-joined', (data) => {
          stats.messageCount++;
          updateStats();
          log(`üö™ Joined room: ${data.roomId}`, 'success');
        });

        socket.on('room-left', (data) => {
          stats.messageCount++;
          updateStats();
          log(`üëã Left room: ${data.roomId}`, 'info');
        });

        // Story/Job progress events
        socket.on('story:progress', (data) => {
          stats.messageCount++;
          updateStats();
          log(
            `üìä Story progress: ${data.progress}% - ${data.message}`,
            'success'
          );
          updateProgress(data.progress, data.message);
        });

        socket.on('story:completed', (data) => {
          stats.messageCount++;
          updateStats();
          log(`‚úÖ Story completed!`, 'success');
          updateProgress(100, 'Completed successfully!');
        });

        socket.on('story:failed', (data) => {
          stats.messageCount++;
          updateStats();
          log(`‚ùå Story failed: ${data.error}`, 'error');
          updateProgress(data.progress || 0, `Failed: ${data.error}`);
        });

        // Generic progress events
        socket.on('progress', (data) => {
          stats.messageCount++;
          updateStats();
          log(`üìä Progress update: ${JSON.stringify(data)}`, 'info');
        });

        socket.on('socket:error', (data) => {
          stats.messageCount++;
          updateStats();
          log(`‚ö†Ô∏è Socket error event: ${data.error}`, 'error');
        });
      }

      function startKeepAlivePing() {
        // Send ping every 30 seconds to keep connection alive during long jobs
        // This is less than the server's pingInterval (45s) and well within pingTimeout (120s)
        if (pingInterval) clearInterval(pingInterval);

        pingInterval = setInterval(() => {
          if (socket && socket.connected) {
            socket.emit('ping');
            stats.pingCount++;
            updateStats();
            log('üíì Sent keep-alive ping', 'info');
          }
        }, 30000); // 30 seconds - more relaxed but still safe
      }

      function disconnect() {
        if (socket) {
          socket.disconnect();
          socket = null;

          if (pingInterval) {
            clearInterval(pingInterval);
            pingInterval = null;
          }

          if (uptimeInterval) {
            clearInterval(uptimeInterval);
            uptimeInterval = null;
          }

          log('Disconnected manually', 'warning');
        }
      }

      function joinRoom() {
        if (!socket || !socket.connected) {
          log('Not connected! Connect first.', 'error');
          return;
        }

        const roomId = document.getElementById('roomId').value;
        socket.emit('join:user', roomId);
        log(`Joining room: ${roomId}`, 'info');
      }

      function leaveRoom() {
        if (!socket || !socket.connected) {
          log('Not connected! Connect first.', 'error');
          return;
        }

        const roomId = document.getElementById('roomId').value;
        socket.emit('leave-room', roomId);
        log(`Leaving room: ${roomId}`, 'info');
      }

      function sendPing() {
        if (!socket || !socket.connected) {
          log('Not connected! Connect first.', 'error');
          return;
        }

        socket.emit('ping');
        stats.pingCount++;
        updateStats();
        log('Sent manual ping', 'info');
      }

      function simulateLongJob() {
        log('üöÄ Simulating long-running job (15+ minutes)...', 'info');
        log('üí° Keep-alive pings will maintain the connection', 'warning');

        // Simulate progress updates over 15 minutes
        let progress = 0;
        const totalDuration = 15 * 60 * 1000; // 15 minutes
        const updateInterval = 30000; // Update every 30 seconds
        const progressIncrement = (updateInterval / totalDuration) * 100;

        const simulationInterval = setInterval(() => {
          progress = Math.min(progress + progressIncrement, 100);

          const messages = [
            'Generating story content...',
            'Processing voice-over...',
            'Creating images...',
            'Generating video scenes...',
            'Merging video segments...',
            'Applying effects...',
            'Finalizing output...',
            'Uploading to cloud...',
          ];

          const messageIndex = Math.floor((progress / 100) * messages.length);
          const message = messages[Math.min(messageIndex, messages.length - 1)];

          updateProgress(Math.floor(progress), message);
          log(
            `üìä Simulated progress: ${Math.floor(progress)}% - ${message}`,
            'info'
          );

          if (progress >= 100) {
            clearInterval(simulationInterval);
            log('‚úÖ Simulated job completed!', 'success');
            updateProgress(100, 'Simulation completed successfully!');
          }
        }, updateInterval);
      }

      function clearLogs() {
        document.getElementById('eventLog').innerHTML = '';
        stats.pingCount = 0;
        stats.messageCount = 0;
        updateStats();
      }

      // Auto-connect on load
      window.addEventListener('load', () => {
        log('Page loaded. Ready to connect.', 'info');
      });
    </script>
  </body>
</html>
